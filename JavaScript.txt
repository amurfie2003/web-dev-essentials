                        __________________________________  
=====================  |               JAVASCRIPT         |   ==================
=====================  |__________________________________|   ==================

GENERAL JS Concepts to remember 
-------------------------
ASI applies to let/const import/export and return
break; //used to force exit loop
continue; //skips an iteration of the loop
try...catch //error handling 
reference types and mutability
  [] === []; //false
  {} === {}; //false

callbacks - passing a function definition as parameter

typeof variable //returns the datatype of variable

let username = '';
let defaultName = username || 'Stranger';// short-circuit evaluation

comparing same value use a switch statement instead of if/else
switch('item'){
 case 'mango':
        console.log('mangoes are $1.50');
        break;
 default:
        console.log('invalid item');
        break;
}



                        __________________________________  
=====================  |               STRINGS            |   ==================
=====================  |__________________________________|   ==================
toUpperCase() //transform string to uppercase
toLowerCase() //transform string to lowercase

substring() 
  someString.substring(indexStart, indexEnd)
  extracts a part of a string. indexEnd is optional and is not inclusive.

startsWith() // return true or false
endsWith() //returns true or false 
includes()
trim() //gets rid of whitespace at the start and end of a string
split()//Seperates a string based on the given input
replace()
replaceAll()
Number.parseInt()//Converts a string into a number when possible
.length //returns the length of the string

Accessing String index
----------------------
You can access the index of a character in a string using
string[0] //retuns the first character.






                        __________________________________  
=====================  |               ARRAYS             |   ==================
=====================  |__________________________________|   ==================
.push()//add to end
.pop()//remove last item and return item removed
.map() //return new transformed array
.filer() //return new array of items that passed condition
.reduce() //reduce to single value.reducer and initial value.Array unchanged.
.find() //return first item passed condition or undifined
.forEach() //iterate. HAS NO RETURN STATEMENT
.join() //turn to string
.reverse() //reverse
.every() //return true when all items meet condition else return false
.some()	//return true when atleast one item statisfies condition else return false
.splice(0 , 3) //remove from index exclusive. return removed item
.shift()// delete from front of list
.unshift('popcorn') //add to the front of the list
.length //returns number of elements in the array

=====QUICK CONCEPTS===================
[...items, apple] spread array. creates new array
const [a , b] = [] destructuring array
undefined returned for index that does'nt exist
myArry[0] = 'new item' will update array at that index
for (const fruit of fruits)//iterate array for-of-loop
======================================










                        __________________________________  
=====================  |               OBJECTS            |   ==================
=====================  |__________________________________|   ==================
Object[] //dynamic key value
Object.keys(myObject) //returns array of keys 
Object.values(myObject) //returns array of values
Object.entries(myObject) //return array of arrays [ [key, value] ]
for (let creMember in crew) //iterate object key

=====QUICK CONCEPTS=============================================================
-let{a = 0 , b: c} = {} //destructuring and name reassignment and default value
-{...{}, ...{}} //spread object.Duplicate keys exist the last overwrites first
-return user.info?.name; //optional chaining short-circuit to undifined
 const firstValue = data.temperatures?.[0]; //optional chaining with array value
 const upperCasedName = person.name?.toUpperCase();//optional chaining method call
 Optional chaining cannot be used for assignment. It's only used for reading
- ?? nullish coalescing operator
   return user.age ?? 'unknown'; //if left is null or undifined execute right
   const name = user.details?.name?.firstName ?? "N/A"; //combining both
-const copy = {...{}, darkTheme: true} immutable copy and add key/value
-const clonedUser = {...user, age: user.age + 1}; immutable copy and update age
-[object object] error // means toString() called on object instead of string
-use object to replace multiple if/else conditions


















                        __________________________________  
=====================  |               CLASSES            |   ==================
=====================  |__________________________________|   ==================
the class constructor creates an object
internal method call with this.methodName() 
getters and setters validate values to be set as properties on the class
  set amount(value){
    this._cents = value * 100;
  }
  get amount(){
    return this._cents;
  }
use _ for internal properties
static methods are called on the class not the instance
static methods cannot access 'this' keyword
  static getYear(){

  }
method chaining - must retun 'this' to work
class inheritance (Child Extends Parent)
method override
Super(fName, lName, newVariable) (calls parent constructor and overides it)
super.parentMethod() 
constructor function and prototypes
all instance variables are part of the class object
#private field and method. only inside class useage. defined outside constructor
prototypical inheritance allows you to select methods you want to inherit
  GorillaBanana.prototype.eat = Gorilla.prototype.eat;
  extends simulates classical inheritance by copying all methods in the prototype
  Every object in JavaScript inherits the prototype of Object.






                        __________________________________  
=====================  |               PROMISES           |   ==================
=====================  |__________________________________|   ==================
Promises are used when doing asyncronous work
try...catch does not work with Promises
states: pending, resolved, rejected
promises.then(future callback).catch(error handling)
.finally(); //runs after .then or .catch 
throw new Error('there was an error') inside .then block skips to .catch() block
return new Promise( (resolve, reject) =>{ resolve(data); reject(error);});
  must return new Promise(); when creating promise
when you call resolve(); state changes to fulfilled .then() callbacked will execute
when you call reject(); state changes to rejected .catch() callbacked will execute






                        __________________________________  
=====================  |               JSON               |   ==================
=====================  |__________________________________|   ==================
This is a JSON string not an object it needs to be converted into an object
  '{
      "firstName": "Sam",
      "lastName": "Green",
      "age": 24
  }'

  An APi cannot receive an object or send and object it must be a JSON string.
JSON.parse(string) //converts JSON string to JSON object
  This function is synchronous. This means that it will block the main thread. 
  .json() method is used by fetch() almost the same as JSON.parse().
JSON.stringify(object) //converts an object into a JSON string



                        __________________________________  
=====================  |               HTTP               |   ==================
=====================  |__________________________________|   ==================
status responses
1xx infomational responses
2xx successful responses
  -200 ok
3xx redirects
  -301 moved permanently
  -302 found
4xx client errors 
  -401 unauthorized
  -404 not found
5xx server errors
  -503 gateway timeout

methods
GET: read data
POST: create data
PUT: update data
DELETE: delete data

when sending a body to the api convert it to a json string.
 body: JSON.stringify({})










                        __________________________________  
=====================  |               FETCH API          |   ==================
=====================  |__________________________________|   ==================
fetch('url string') //will send an ajax request and return a <promise>
resolving the <pronise> will return a generic Response object which needs to be converted into a specific format mostly json using .json() method which is non-blocking since it returns a new <promise>. Remember to return response.json()

These will not work
  const data = fetch("...").then(response => response.json());

let apiData;
fetch("...")
.then(response => response.json())
.then(data => {
    apiData = data;
});
console.log(apiData);

//You will end up getting undefined, that's because your code runs top to bottom and by the time console.log(apiData) runs, the promise is still pending. So the callback of the .then() has not run yet.

fetch will fail for network errors and execute the catch block but not for error responses. For most APIs, you can check if the response was successful by reading response.ok.

fetch also takes a second parameter for sending HTTP requests.
  fetch('url string', {
    method: 'POST',
    headers: {
       "Content-Type": "application/json"
    },
    body: JSON.stringify({
      key1: 'value1',
      key2: 'value2'
    })
  })



                        __________________________________  
=====================  |               ES MODULES         |   ==================
=====================  |__________________________________|   ==================
Every javascript file is called a module. Each module is seperate from other modules.
must use this format './helpers.js' 
  therefore file must be in the same folder.
imports must be at the top of the file before all other code(it is synchronous)
must use webpack or <script type="module" src="index.js"></script> for this to work
  
export class Helper{}
import {Helper} from './helpers.js' //named export

default export
---------------
  export default class Helper{} 
  import Helper from './helpers.js'
              OR
  export default class Helper{}
  import StringHelper from './helpers.js'
with default exports you can re-name them when importing them.The '{}' are also removed when importing. A default and named export can be used in the same module.Therefore this is valid
  import Helper, {votingAge} from "./helpers.js";

It is possible but not recommended to rename a named export as follows
  import {getDate as getDateHelper} from "./date-helpers.js"; 

When importing from a liberary the name of the liberary is used not the file path 










                        __________________________________  
=====================  |               DOM                |   ==================
=====================  |__________________________________|   ==================
The DOM is the HTML representation of your page which you can access & manipulate with JavaScript

Selecting A Single element
--------------------------
- document.querySelector("your-CSS-selector-here"); 
    Selects a single item. If there are multiple items that satisfy the CSS selector that you specified, only the first one is returned. 
    document.getElementById('id') can be used but can only select ids
    X getElementsByTagName() //outdated should not be ued
    X getElementsByClassName() //outdated should not be used

    Type selectors
      const title = document.querySelector("h1");

    ID selector
      const navbar = document.querySelector("#navbar");

    class selector
      const item = document.querySelector(".item");

    Descendant selector
       const item = document.querySelector("#banner .item");


    Attribute selector
       document.querySelector("[disabled]");

  Assuming the following HTML:

  <a href="/contact-us" class="menu-link">Contact us</a>
  <script>
      const incorrect = document.querySelector("a .menu-link")
      const correct = document.querySelector("a.menu-link")
  </script>

    The first selector will not work because a .menu-link means that there is an a element and then inside of it you should find an element with class="menu-link". This is incorrect
    This is because the a and the element that has the class="menu-link" are the same element
    In that case, the correct selector is a.menu-link (without spaces between them)
    Similarly, you can select an item that has several classes, for example, 
    .menu-link.active will select the item that has both classes menu-link and active

  practice selectors: 
    https://flukeout.github.io/

  document.querySelector("CSS-selector") returns an object which is an instance of HTMLElement.HTMLElement is the parent class that every single HTML element in your page inherits from. This means that every element on your page is an instance of a single class which is HTMLElement. when document.querySelector() cannot find the element you're looking for, it will return null.

  .textContent
  -------------
  textContent will return the text, with all the HTML tags stripped out. You can use if() checks and optional chaining to handle null returns.
   .textContent
   
  element.textContent = "This is the new text!"; 
    this will change the text inside the element. HTML tags in the string will not render into HTML it will simply be plain text string. This makes it safe to accept user input as <script> tags will be text and not able to execute JS code.

Selecting Multiple Elements
---------------------------
- document.querySelectorAll("CSS-selector");
    While document.querySelector() might return null (when no items are found), the document.querySelectorAll() will always return a NodeList.A NodeList is a collection of DOM elements. This means that it is a variable that contains several DOM elements.The NodeList object is similar to an array, but it's not an array document.querySelectorAll() will always return a NodeList, of 0 or more DOM elements.

    NodeList
  ------------
  A nodelist is not an array however:
  it has a length property
  it has indexes accessible with [0] syntax
  you can use .forEach() method for iteration

  you cannot call .filter on a node list. Calling .textContent will also never work as there's no textContent property on the NodeList object. It has to be called on a single element. This is why we need to loop through the node list one by one with .forEach()

      Convert NodeList to Array
      -------------------------
      const divs = document.querySelectorAll("div"); // NodeList
      const items = [...divs]; // Array

      Or, in a single line:
        const items = [...document.querySelectorAll("div")]; // Array

      You can now use array methods for example, filter all the a links that have a textContent of Login using the following code:

      const links = document.querySelectorAll("a");
      const loginLinks = [...links].filter(link => link.textContent === "Login");
      console.log(loginLinks); // Array of 2 links that have "Login" as textContent

InnerHTML
---------
innerHTML will return the HTML string inside of the element (it will not strip out HTML tags).

  <div id="test">This is a <strong>sample text</strong></div>  

      const element = document.querySelector("#test");
      console.log(element.textContent); // "This is a sample text"
      console.log(element.innerHTML); // "This is a <strong>sample text</strong>"
Never use innerHTML with input coming from the user. Cross-Site Scripting (XSS) attack is possible.

Emptying elements
-----------------
  <div id="banner">
    <h1>Hello World</h1>
    <p>lorem ipsum</p>
  </div>
  
  const banner = document.querySelector("#banner");
  banner.innerHTML = ""; // OR banner.textContent = "";
  This will empty all the content inside the div with id "banner", without removing the banner itself. So in this example, it only removes the h1 and p that are inside.

value
-----
To read the written content of an input element, you have to use value property:
    <form>
      <input type="email" id="email" placeholder="Enter your email">
      <input type="submit" value="Register">
    </form>

    const email = document.querySelector("#email");
    console.log(email.textContent); // undefined (there's no closing tag)
    console.log(email.value); // text written in the email field

    whenever you'd like to read the value written inside of an <input>, a <select>, or a <textarea> you have to access the value property.


Element ClassList
------------------
The classList Object can only be accessed on one element. In the case of a node list you must loop through the list.

element.classList.add(className)
  const element = document.querySelector("#first-item");
  element.classList.add("highlighted");
    adds the class highlighted to the selected element.

  you can add multiple classes at the sametime
    element.classList.add("active", "highlighted", "dark");


element.classList.remove(className)
  const element = document.querySelector("#first-item");
  element.classList.remove("highlighted");
     removes the class highlighted from the selected element.

  you can remove multiple classes at the sametime
    element.classList.remove("active", "highlighted", "dark");

element.classList.contains(className)
    const box = document.querySelector("#box");
    box.classList.contains("activated"); // true
    box.classList.contains("highlighted"); // false
      checks if the class is present on the element. Returns true or false.

element.classList.toggle(className)
    const box = document.querySelector("#box");
    box.classList.toggle("activated"); // adds the class activated (because it wasn't there)
    box.classList.toggle("activated"); // removes the class activated (because it was already added)
    box.classList.toggle("activated"); // adds the class activated (because it wasn't there)

element.classList.replace(oldClassName, newClassName)
    instead of using the following two lines:

      element.classList.remove("hidden");
      element.classList.add("show");

    you can use the following:

      element.classList.replace("hidden", "show");



Element get Attribute
---------------------
element.getAttribute(key)
    used to get the value of a certain attribute by its key.    

    <div id="banner">
      <button disabled="disabled" id="login">Login</button>
    </div>   
    
    const banner = document.querySelector("#banner");
    banner.getAttribute("id"); // "banner"
    banner.getAttribute("disabled"); // null (attribute not found on this element)

    const button = document.querySelector("#login");
    button.getAttribute("disabled"); // "disabled"

element.removeAttribute(key)
    used to remove an attribute.

element.setAttribute(key, value)
    used to write a new attribute (or update the value of an old one that already exists).The 2nd argument for setAttribute() is always required.

element.hasAttribute(key)
    used to check whether an attribute exists or not. The function always returns a boolean.

style
-------
Using the DOM, you can update any CSS property from JavaScript using 
element.style.property. We do recommend that you update classes instead of styles directly when possible.It's almost the same as CSS. The only difference is that we've got to use camelCase rather than kebab case. Single-worded properties remain the same, and those that contain a dash need to be converted to camel case.

change backround color
    <div id="banner">Welcome!</div>
    const banner = document.querySelector("#banner");
    banner.style.backgroundColor = "red";

    
    CSS	              JavaScript
    background-color	backgroundColor
    color	            color
    font-size	        fontSize
    z-index	          zIndex


Showing/hiding element
You could do this in 2 ways:
Using CSS classes that can be added/removed in JavaScript with classList.
Using JavaScript to modify the style of the element using the style property.

using the 2nd approach:
    <div id="banner">Welcome!</div>

    const banner = document.querySelector("#banner");

    // hide element 
    banner.style.display = "none";

    // show element by resetting its display
    banner.style.display = ""; //or "initial"

    Note that initial is a CSS value that works on most CSS properties and means that the browser should use the initial value the element had. Examples:
    A <div> has an initial display of block.
    A <strong> has an initial display of inline.
    An <img> has an initial display of inline-block.




Removing element from the DOM
-----------------------------
If you'd like to remove an element from the DOM, you can use the .remove() method. 

element.remove()
    const headline = document.querySelector("#headline");
    headline.remove();

    The h1#headline will be removed from the DOM. Note that this is different than emptying the contents of an element.


document.body
  If you need to access the <body> element of the page, instead of finding it with querySelector, you can access it with document.body directly:


document.documentElement
Similarly for the <html> tag, you can access it directly with document.documentElement
    document.documentElement.classList.add("dark-mode");


Dataset
--------
 the HTML spec recommends that developers prefix their own custom attributes with data- This avoids potential conflicts with the browser and shows that this is a custom attribute. We call this a data attribute. element.dataset returns an object containing all the data- attributes on that element.

    <-- This is recommended -->
      <form id="payment-form" data-currency="EUR">
        ...
      </form>


  To read this data attribute, you can access the dataset object on the element:
  Notice that the kebab-case (user-id) was automatically converted to camelCase (userId). Also, notice that the value of data attributes is always a string.This may become challenging when reading boolean values. The "false" string is true (because it's a string that contains text).
  const rememberMe = navbar.dataset.rememberMe === "true"; // false

    const form = document.querySelector("#payment-form");
    console.log(form.dataset); // {currency: "EUR"}
    const currency = form.dataset.currency; // "EUR"

    <form id="payment-form" data-currency="EUR" data-user-id="2">
      ...
    </form>

    console.log(form.dataset), you will get:
    {
      userId: "2",
      currency: "EUR"
    }


  write dataset
  --------------
  You can also update/set a value for a data attribute by assigning it to a new value.

  Assuming the following HTML:
  <div id="navbar" data-user-id="42"></div>

  const navbar = document.querySelector("#navbar");
  navbar.dataset.userId = 43;
  navbar.dataset.rememberMe = false;

  The updated DOM element will look like this:
  <div id="navbar" data-user-id="43" data-remember-me="false"></div>


Traversing The DOM
-------------------
Avoid if possible
You should not rely a lot on these methods as changing the HTML would then break your JavaScript code. It's recommended that you add ids and classes whenever possible.

element.parentElement 
  returns the parent element of the current element

  <div class="article">
    <h1>Hello World</h1>
    <p>Lorem ipsum</p>
  </div>

  const h1 = document.querySelector("h1");
  console.log(h1.parentElement); // <div class="article">...</div>

element.closest("CSS-selector")
  returns the closest parent that matches the CSS-selector you specified.

  <div class="main">
    <div class="banner">
        <h1>Hello World</h1>
    </div>
  </div>

  const h1 = document.querySelector("h1");
  console.log(h1.closest(".main")); // <div class="main">...</div>
  This will look for the closest parent that matches the selector .main that will be the first div with class="main".


Insert adjacent HTML
--------------------
Using innerHTML += ... to add HTML inside an element is inefficient because it recreates the entire HTML. This could also remove existing event listeners.
Instead, when you want to add a piece of HTML, you should use the insertAdjacentHTML method. Always use backticks `` for the second argumet.This is because template strings support multiline strings whereas double quotes and single quotes don't.Another benefit of using template strings is interpolation.
The insertAdjacentHTML method presents the same security risk as innerHTML.
So, you should not use it if the variables you're interpolating might be coming from the user.Similarly, we've got the insertAdjacentText method that will insert text without interpreting HTML.

element.insertAdjacentHTML(position, htmlString)
  will place the htmlString without having to reconstruct the remaining HTML inside the element

  Append
    const positions = document.querySelector("#job-positions");
    positions.insertAdjacentHTML("beforeend", `<div class="position">2015-2020</div>`);
  This will add the html string at the end of the #job-positions element

  Prepend
    const positions = document.querySelector("#job-positions");
    positions.insertAdjacentHTML("afterbegin", `<div class="position">2007-2009</div>`);
  This will add the html string at the begining of the #job-positions element

Array to DOM
  const apps = ["Calculator", "Phone", "Messages"];
  const list = document.querySelector("#apps-list");

  apps.forEach(app => {
    list.insertAdjacentHTML("beforeend", `<li>${app}</li>`);
  });

  The resulting DOM will be:
  <ul id="apps-list">
    <li>Calculator</li>
    <li>Phone</li>
    <li>Messages</li>
  </ul>


innerHTML vs insertAdjacentHTML
  - Do I want to write HTML and overwrite all the previous values? If yes, then  
    use innerHTML.
  - Do I want to keep the previous HTML and add some HTML at the beginning or at 
    the end? If yes, then use insertAdjacentHTML.


Creating elements imperatively
-------------------------------
Instead of writing the html String <p class="text-center">Hello World</p>, you can construct it with the document.createElement() method:

  const paragraph = document.createElement("p");
  paragraph.classList.add("text-center");
  paragraph.textContent = "Hello World";
  console.log(paragraph); // <p class="text-center">Hello World</p> (as an element not as a string)

  You can then use the element.appendChild() method to append it somewhere in the DOM. For example:

  document.body.appendChild(paragraph);


Add Event Listener
-------------------
element.addEventListener(eventType, callback)
  allows you to wait for an event to happen on an element. Once that event occurs the callback function will execute. Your code is running top to bottom, however, the event listener callback is scheduled into the future (when the user clicks on the button)


Event Details
--------------
The event details contains information about the event that has just occurred. For example, for a click event: 
  x, y cordinate where the click occured 
  currentTarget etc.

  button.addEventListener("click", event => {
    console.log(event); // details of the click event
  });

  Event currentTarget
  The event.currentTarget refers to the element to which the event listener has been attached.If you log event to the browser console, you will see that currentTarget is null. The currentTarget is only available when the event is triggered but you won't be able to read its value later on in the dev tool console.This does not affect your code, you can still use event.currentTarget as long as you use it inside the event callback.

    button.addEventListener("click", event => {
      console.log(event.currentTarget); // same as the variable 'button'
    });

     debugger; // pause execution so that we can see event.currentTarget in the dev tools

    Always use currentTarget and not event.target
    ----------------------------------------------
    <button>
      Hello <strong>world</strong>
    </button>

    const button = document.querySelector("button");

    button.addEventListener("click", event => {
      console.log(event.target); // not recommended
    });
    The event.target here might return either the <button> element or the <strong> element, depending on where the user clicks inside the button. While this can be useful in some scenarios when building User Interface libraries, you will rarely ever need it. This is why you should stick to event.currentTarget. In this example, it'll always return the <button> no matter where the user has clicked inside that button.
  
  multiple Elements
  -----------------
  You can use button instead of event.currentTarget. This is true in this example, but, sometimes you may not have access to the button variable, which is why we prefer that you always use event.currentTarget since it always works!
    
    const buttons = document.querySelectorAll("button");

    buttons.forEach(button => {
      button.addEventListener("click", event => {
        console.log(event.currentTarget); // the <button> that was clicked
      });
    });


Removing Event Listener
------------------------
To remove an event listner you must provide the eventType and the callback function that was used when the event listner was added, therefore you cannot use
an anonymous function. You should not add the () here because you do not want to call handleClick right now, but, instead, reference it.

  const button = document.querySelector("button");

  const handleClick = () => {
    console.log("button clicked");    
  }

  button.addEventListener("click", handleClick);

  button.removeEventListener("click", handleClick);


Once event listener
--------------------
You can add an event listner that only runs once by adding a third argument to the function signature:

  const button = document.querySelector("button");

  button.addEventListener("click", () => {
      console.log("button clicked");
  }, {
      once: true
  });

Focus/Blur event listeners
--------------------------
The focus and blur events are often used in form validation. They let you know when a user focuses (put the cursor inside of it) on a textbox and when they remove the focus (blur).

  <input type="text" id="name" placeholder="Enter your name">

  const name = document.querySelector("#name");

  name.addEventListener("focus", () => {
      console.log("user focused inside the name");
  });

  name.addEventListener("blur", () => {
      console.log("user removed focus from the name");
  });



DOMContentLoaded
-----------------
This event fires on the document element only. It signifies that the HTML has been loaded successfully by the browser.
This means that the browser has finished reading all of the content of your HTML file. It doesn't mean however that images and other assets have finished loading.
This event used to be quite popular a few years ago, but nowadays, you can place your <script> at the end of the page (right before the closing tag of the body) and you won't have to worry about waiting until the DOM is ready.


document.addEventListener("DOMContentLoaded", () => {
    console.log("DOM is ready");
});

Scroll
-------
The scroll event triggers on any element that scrolls. It is often used on the window object.However, adding a scroll event will most likely slow down your page. Its usage is discouraged.


window.addEventListener("scroll", () => {
    console.log("page scrolled");
});

change
------
The change event is often used on the <select> element. It lets you know when the user has selected a new choice.

  <select id="countries">
    <option value="">Select a country</option>
    <option value="NL">Netherlands</option>
    <option value="BR">Brazil</option>
  </select>

  const countries = document.querySelector("#countries");

  countries.addEventListener("change", () => {
    console.log(countries.value);
  });


keydown/keyup
------------- 
The keydown and keyup events are used to know when the user has typed a character on the keyboard. These can be used to implement keyboard shortcuts.
The only difference between keydown and keyup is that keydown triggers while the user starts pressing the button and before the character is being typed. On the other hand, keyup fires after the character has been typed. For most scenarios, you end up needing keyup.Notice that we can know which character was pressed by reading the event.key.


  document.addEventListener("keydown", event => {
    console.log(event.key);
  });

  document.addEventListener("keyup", event => {
    console.log(event.key);
  });

                        _________________________________ 
=====================  |               FORMS             |   ==================
=====================  |_________________________________|   ==================
A <form> element groups several inputs together and separates multiple forms on a web page.

Requirements for the "submit" event
------------------------------------
  have a form element
  have at least 1 input or textarea inside of the form
  have a button with type="submit"
  The button could either be an <input type="submit" value="..."> or a <button type="submit">...</button>.

Listening for the submit event
-------------------------------
The addEventListener has to be on the <form>

  <form id="address-form">
    <input type="text" placeholder="Enter your address">
    <input type="submit" value="Save">
  </form>

  const form = document.querySelector("#address-form");

  form.addEventListener("submit", event => {
      // event callback (when the form is submitted)
  });


Prevent default
----------------
When you submit a form, the browser will take all the values your user has written and send them to the backend of your website. However, this causes the whole page to be reloaded. That's because the browser will send the data to the same URL by default unless you specify the form's action attribute.As long as you add a submit event listener to a form, then you will need to prevent the default, or else your code will not run as the page will reload.

  form.addEventListener("submit", event => {
    event.preventDefault();
    // the form will not reload anymore
  });


User input for form submission
-------------------------------
Always make sure to access the value property inside the submit event to get the value when the user submitted the form. DO NOT access it outside the submit event 
as the value will be empty or incomplete.You want to get the value on submision.

  <form id="weather-form">
    <input type="text" id="city" placeholder="Enter your city">
    <input type="submit" value="Show weather">
  </form>

  const form = document.querySelector("#weather-form");
  const city = document.querySelector("#city");

  form.addEventListener("submit", event => {
      event.preventDefault();

      // read the user's city and pass it to getWeatherInfo()
      console.log(city.value); // see in the console to make sure it's working
      getWeatherInfo(city.value);
  });




                        _________________________________ 
=====================  |               DOM & FETCH       |   ==================
=====================  |_________________________________|   ==================

Fetch on click
--------------
  <button id="button">Get data</button>
  <div id="result"></div>

  const button = document.querySelector("#button");
  const result = document.querySelector("#result");
  const API = new FetchWrapper("https://jsdemo-3f387-default-rtdb.europe-west1.firebasedatabase.app");

  button.addEventListener("click", () => {
      // make a fetch request on click
      API.get("/notifications/new.json").then(data => {
          console.log(data);
          result.textContent = data.message;
      });
  });

Fetch on submit
----------------
  <form id="form">
    <input type="text" id="input" />
    <input type="submit" />
  </form>

  const form = document.querySelector("#form");
  const input = document.querySelector("#input");
  const API = new FetchWrapper("https://api.learnjavascript.online");

  form.addEventListener("submit", event => {
      event.preventDefault();

      API.put("/demo/grades.json", {
          grade: input.value
      }).then(data => {
          console.log(data);
      });
  });


