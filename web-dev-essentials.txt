                        __________________________________  
=====================  |               HTML               |   ==================
=====================  |__________________________________|   ==================
Attributes - key/value
href="#myid" - link to id on page

         
         
         
         
         
         
         
         
         
         
                        __________________________________  
=====================  |               CSS                |   ==================
=====================  |__________________________________|   ==================
css ruleset 
p{
  color: blue;
}
css inline style
<p style="color:blue; font-size: 20px;"></p>

type/element selector 
.class selector
#id selector
[src] OR img[src*='winter'] attribute selector

pseudo-class 
used for different states
p:hover {
        color: green
}

Specificity
1. id
2. Class
3. element

p {
  color: blue;
}
 
.main p {
  color: red;
}  //more spefic



chaining
h1.special {
 
}
The code above would select only the <h1> elements with a class of special. If a <p> element also had a class of special, the rule in the example would not style the paragraph.

Descendant Combinator
<ul class='main-list'>
  <li> ... </li>
  <li> ... </li>
  <li> ... </li>
</ul>
The nested <li> elements are descendants of the <ul> element and can be selected with the descendant combinator like so:
.main-list li {
 
}

Multiple Selectors
h1, 
.menu {
  font-family: Georgia;
}

!important
p {
  color: blue !important;
}
only used in extreme circomstances




                        __________________________________  
=====================  |               BROWSER            |  ==================
=====================  |__________________________________|   ==================
about:blank //create blank page in browser











                        __________________________________  
=====================  |               JAVASCRIPT         |   ==================
=====================  |__________________________________|   ==================

GENERAL JS Concepts to remember 
-------------------------
ASI applies to let/const import/export and return
break; //used to force exit loop
continue; //skips an iteration of the loop
try...catch //error handling 
reference types and mutability
  [] === []; //false
  {} === {}; //false

callbacks - passing a function definition as parameter

typeof variable //returns the datatype of variable

let username = '';
let defaultName = username || 'Stranger';// short-circuit evaluation

comparing same value use a switch statement instead of if/else
switch('item'){
 case 'mango':
        console.log('mangoes are $1.50');
        break;
 default:
        console.log('invalid item');
        break;
}



                        __________________________________  
=====================  |               STRINGS            |   ==================
=====================  |__________________________________|   ==================
toUpperCase() //transform string to uppercase
toLowerCase() //transform string to lowercase
substring() // extracts a part of a string
startsWith() // return true or false
endsWith() //returns true or false 
includes()
trim() //gets rid of whitespace at the start and end of a string
split()//Seperates a string based on the given input
replace()
replaceAll()
Number.parseInt()//Converts a string into a number when possible
.length //returns the length of the string

Accessing String index
----------------------
You can access the index of a character in a string using
string[0] //retuns the first character.



                        __________________________________  
=====================  |               ARRAYS             |   ==================
=====================  |__________________________________|   ==================
.push()//add to end
.pop()//remove last item and return item removed
.map() //return new transformed array
.filer() //return new array of items that passed condition
.reduce() //reduce to single value.reducer and initial value.Array unchanged.
.find() //return first item passed condition or undifined
.forEach() //iterate. HAS NO RETURN STATEMENT
.join() //turn to string
.reverse() //reverse
.every() //return true when all items meet condition else return false
.some()	//return true when atleast one item statisfies condition else return false
.splice(0 , 3) //remove from index exclusive. return removed item
.shift()// delete from front of list
.unshift('popcorn') //add to the front of the list
.length //returns number of elements in the array

=====QUICK CONCEPTS===================
[...items, apple] spread array. creates new array
const [a , b] = [] destructuring array
undefined returned for index that does'nt exist
myArry[0] = 'new item' will update array at that index
for (const fruit of fruits)//iterate array for-of-loop
======================================










                        __________________________________  
=====================  |               OBJECTS            |   ==================
=====================  |__________________________________|   ==================
Object[] //dynamic key value
Object.keys(myObject) //returns array of keys 
Object.values(myObject) //returns array of values
Object.entries(myObject) //return array of arrays [ [key, value] ]
for (let creMember in crew) //iterate object key

=====QUICK CONCEPTS=============================================================
-let{a = 0 , b: c} = {} //destructuring and name reassignment and default value
-{...{}, ...{}} //spread object.Duplicate keys exist the last overwrites first
-return user.info?.name; //optional chaining short-circuit to undifined
 const firstValue = data.temperatures?.[0]; //optional chaining with array value
 const upperCasedName = person.name?.toUpperCase();//optional chaining method call
 Optional chaining cannot be used for assignment. It's only used for reading
- ?? nullish coalescing operator
   return user.age ?? 'unknown'; //if left is null or undifined execute right
   const name = user.details?.name?.firstName ?? "N/A"; //combining both
-const copy = {...{}, darkTheme: true} immutable copy and add key/value
-const clonedUser = {...user, age: user.age + 1}; immutable copy and update age
-[object object] error // means toString() called on object instead of string
-use object to replace multiple if/else conditions










                        __________________________________  
=====================  |               CLASSES            |   ==================
=====================  |__________________________________|   ==================
the class constructor creates an object
internal method call with this.methodName() 
getters and setters validate values to be set as properties on the class
  set amount(value){
    this._cents = value * 100;
  }
  get amount(){
    return this._cents;
  }
use _ for internal properties
static methods are called on the class not the instance
static methods cannot access 'this' keyword
  static getYear(){

  }
method chaining - must retun 'this' to work
class inheritance (Child Extends Parent)
method override
Super(fName, lName, newVariable) (calls parent constructor and overides it)
super.parentMethod() 
constructor function and prototypes
all instance variables are part of the class object
#private field and method. only inside class useage. defined outside constructor
prototypical inheritance allows you to select methods you want to inherit
  GorillaBanana.prototype.eat = Gorilla.prototype.eat;
  extends simulates classical inheritance by copying all methods in the prototype
  Every object in JavaScript inherits the prototype of Object.






                        __________________________________  
=====================  |               PROMISES           |   ==================
=====================  |__________________________________|   ==================
Promises are used when doing asyncronous work
try...catch does not work with Promises
states: pending, resolved, rejected
promises.then(future callback).catch(error handling)
.finally(); //runs after .then or .catch 
throw new Error('there was an error') inside .then block skips to .catch() block
return new Promise( (resolve, reject) =>{ resolve(data); reject(error);});
  must return new Promise(); when creating promise
when you call resolve(); state changes to fulfilled .then() callbacked will execute
when you call reject(); state changes to rejected .catch() callbacked will execute



                        __________________________________  
=====================  |               JSON               |   ==================
=====================  |__________________________________|   ==================
This is a JSON string not an object it needs to be converted into an object
  '{
      "firstName": "Sam",
      "lastName": "Green",
      "age": 24
  }'

  An APi cannot receive an object or send and object it must be a JSON string.
JSON.parse(string) //converts JSON string to JSON object
  This function is synchronous. This means that it will block the main thread. 
  .json() method is used by fetch() almost the same as JSON.parse().
JSON.stringify(object) //converts an object into a JSON string



                        __________________________________  
=====================  |               HTTP               |   ==================
=====================  |__________________________________|   ==================
status responses
1xx infomational responses
2xx successful responses
  -200 ok
3xx redirects
  -301 moved permanently
  -302 found
4xx client errors 
  -401 unauthorized
  -404 not found
5xx server errors
  -503 gateway timeout

methods
GET: read data
POST: create data
PUT: update data
DELETE: delete data

when sending a body to the api convert it to a json string.
 body: JSON.stringify({})


                        __________________________________  
=====================  |               FETCH API          |   ==================
=====================  |__________________________________|   ==================
fetch('url string') //will send an ajax request and return a <promise>
resolving the <pronise> will return a generic Response object which needs to be converted into a specific format mostly json using .json() method which is non-blocking since it returns a new <promise>. Remember to return response.json()

These will not work
  const data = fetch("...").then(response => response.json());

let apiData;
fetch("...")
.then(response => response.json())
.then(data => {
    apiData = data;
});
console.log(apiData);

//You will end up getting undefined, that's because your code runs top to bottom and by the time console.log(apiData) runs, the promise is still pending. So the callback of the .then() has not run yet.

fetch will fail for network errors and execute the catch block but not for error responses. For most APIs, you can check if the response was successful by reading response.ok.

fetch also takes a second parameter for sending HTTP requests.
  fetch('url string', {
    method: 'POST',
    headers: {
       "Content-Type": "application/json"
    },
    body: JSON.stringify({
      key1: 'value1',
      key2: 'value2'
    })
  })



                        __________________________________  
=====================  |               ES MODULES         |   ==================
=====================  |__________________________________|   ==================
Every javascript file is called a module. Each module is seperate from other modules.
must use this format './helpers.js' 
  therefore file must be in the same folder.
imports must be at the top of the file before all other code(it is synchronous)
must use webpack or <script type="module" src="index.js"></script> for this to work
  
export class Helper{}
import {Helper} from './helpers.js' //named export

default export
---------------
  export default class Helper{} 
  import Helper from './helpers.js'
              OR
  export default class Helper{}
  import StringHelper from './helpers.js'
with default exports you can re-name them when importing them.The '{}' are also removed when importing. A default and named export can be used in the same module.Therefore this is valid
  import Helper, {votingAge} from "./helpers.js";

It is possible but not recommended to rename a named export as follows
  import {getDate as getDateHelper} from "./date-helpers.js"; 

When importing from a liberary the name of the liberary is used not the file path 



                        __________________________________  
=====================  |               DOM                |   ==================
=====================  |__________________________________|   ==================

The DOM is the HTML representation of your page which you can access & manipulate with JavaScript

Selecting A Single element
--------------------------
- document.querySelector("your-CSS-selector-here"); 
    Selects a single item. If there are multiple items that satisfy the CSS selector that you specified, only the first one is returned. 
    document.getElementById('id') can be used but can only select ids
    X getElementsByTagName() //outdated should not be ued
    X getElementsByClassName() //outdated shold not be used

    Type selectors
      const title = document.querySelector("h1");

    ID selector
      const navbar = document.querySelector("#navbar");

    class selector
      const item = document.querySelector(".item");

    Descendant selector
       const item = document.querySelector("#banner .item");


    Attribute selector
       document.querySelector("[disabled]");

  Assuming the following HTML:

  <a href="/contact-us" class="menu-link">Contact us</a>
  <script>
      const incorrect = document.querySelector("a .menu-link")
      const correct = document.querySelector("a.menu-link")
  </script>

    The first selector will not work because a .menu-link means that there is an a element and then inside of it you should find an element with class="menu-link". This is incorrect
    This is because the a and the element that has the class="menu-link" are the same element
    In that case, the correct selector is a.menu-link (without spaces between them)
    Similarly, you can select an item that has several classes, for example, 
    .menu-link.active will select the item that has both classes menu-link and active

  practice selectors: 
    https://flukeout.github.io/

  document.querySelector("CSS-selector") returns an object which is an instance of HTMLElement.HTMLElement is the parent class that every single HTML element in your page inherits from. This means that every element on your page is an instance of a single class which is HTMLElement. when document.querySelector() cannot find the element you're looking for, it will return null.

  .textContent
  -------------
  textContent will return the text, with all the HTML tags stripped out. You can use if() checks and optional chaining to handle null returns.
   .textContent
   
  element.textContent = "This is the new text!"; 
    this will change the text inside the element. HTML tags in the string will not 
    render into HTML it will simply be plain text string. This makes it safe to accept user input as <script> tags will be text and not able to execute JS code.

Selecting Multiple Elements
---------------------------
- document.querySelectorAll("CSS-selector");
    While document.querySelector() might return null (when no items are found), the document.querySelectorAll() will always return a NodeList.A NodeList is a collection of DOM elements. This means that it is a variable that contains several DOM elements.The NodeList object is similar to an array, but it's not an array document.querySelectorAll() will always return a NodeList, of 0 or more DOM elements.

    NodeList
  ------------
  A nodelist is not an array however:
  it has a length property
  it has indexes accessible with [0] syntax
  you can use .forEach() method for iteration

  you cannot call .filter on a node list. Calling .textContent will never work as there's no textContent property on the NodeList object. It has to be called on a single element. This is why we need to loop through the node list one by one with .forEach()
      Convert NodeList to Array
      -------------------------
      const divs = document.querySelectorAll("div"); // NodeList
      const items = [...divs]; // Array

      Or, in a single line:
        const items = [...document.querySelectorAll("div")]; // Array

      You can now use array methods for example, filter all the a links that have a textContent of Login using the following code:

      const links = document.querySelectorAll("a");
      const loginLinks = [...links].filter(link => link.textContent === "Login");
      console.log(loginLinks); // Array of 2 links that have "Login" as textContent

InnerHTML
---------
innerHTML will return the HTML string inside of the element (it will not strip out HTML tags).

  <div id="test">This is a <strong>sample text</strong></div>  

      const element = document.querySelector("#test");
      console.log(element.textContent); // "This is a sample text"
      console.log(element.innerHTML); // "This is a <strong>sample text</strong>"
Never use innerHTML with input coming from the user. Cross-Site Scripting (XSS) attack is possible.

Emptying elements
-----------------
  <div id="banner">
    <h1>Hello World</h1>
    <p>lorem ipsum</p>
  </div>
  
  const banner = document.querySelector("#banner");
  banner.innerHTML = ""; // OR banner.textContent = "";
  This will empty all the content inside the div with id "banner", without removing the banner itself. So in this example, it only removes the h1 and p that are inside.

value
-----
To read the written content of an input element, you have to use value property:
    <form>
      <input type="email" id="email" placeholder="Enter your email">
      <input type="submit" value="Register">
    </form>

    const email = document.querySelector("#email");
    console.log(email.textContent); // undefined (there's no closing tag)
    console.log(email.value); // text written in the email field

    whenever you'd like to read the value written inside of an <input>, a <select>, or a <textarea> you have to access the value property.


Element ClassList
------------------
The classList Object can only be accessed on one element. In the case of a node list you must loop through the list.

element.classList.add(className)
  const element = document.querySelector("#first-item");
  element.classList.add("highlighted");
    adds the class highlighted to the selected element.

  you can add multiple classes at the sametime
    element.classList.add("active", "highlighted", "dark");


element.classList.remove(className)
  const element = document.querySelector("#first-item");
  element.classList.remove("highlighted");
     removes the class highlighted from the selected element.

  you can remove multiple classes at the sametime
    element.classList.remove("active", "highlighted", "dark");

element.classList.contains(className)
    const box = document.querySelector("#box");
    box.classList.contains("activated"); // true
    box.classList.contains("highlighted"); // false
      checks if the class is present on the element. Returns true or false.

element.classList.toggle(className)
    const box = document.querySelector("#box");
    box.classList.toggle("activated"); // adds the class activated (because it wasn't there)
    box.classList.toggle("activated"); // removes the class activated (because it was already added)
    box.classList.toggle("activated"); // adds the class activated (because it wasn't there)

element.classList.replace(oldClassName, newClassName)
    instead of using the following two lines:

      element.classList.remove("hidden");
      element.classList.add("show");

    you can use the following:

      element.classList.replace("hidden", "show");



Element get Attribute
---------------------
element.getAttribute(key)
    used to get the value of a certain attribute by its key.    

    <div id="banner">
      <button disabled="disabled" id="login">Login</button>
    </div>   
    
    const banner = document.querySelector("#banner");
    banner.getAttribute("id"); // "banner"
    banner.getAttribute("disabled"); // null (attribute not found on this element)

    const button = document.querySelector("#login");
    button.getAttribute("disabled"); // "disabled"

element.removeAttribute(key)
    used to remove an attribute.

element.setAttribute(key, value)
    used to write a new attribute (or update the value of an old one that already exists).The 2nd argument for setAttribute() is always required.

element.hasAttribute(key)
    used to check whether an attribute exists or not. The function always returns a boolean.

style
-------
Using the DOM, you can update any CSS property from JavaScript using 
element.style property. We do recommend that you update classes instead of styles directly when possible.It's almost the same as CSS. The only difference is that we've got to use camelCase rather than kebab case.Single-worded properties remain the same, and those that contain a dash need to be converted to camel case.

change backround color
    <div id="banner">Welcome!</div>
    const banner = document.querySelector("#banner");
    banner.style.backgroundColor = "red";

    
    CSS	              JavaScript
    background-color	backgroundColor
    color	            color
    font-size	        fontSize
    z-index	          zIndex


Showing/hiding element
You could do this in 2 ways:
Using CSS classes that can be added/removed in JavaScript with classList.
Using JavaScript to modify the style of the element using the style property.

using the 2nd approach:
    <div id="banner">Welcome!</div>

    const banner = document.querySelector("#banner");

    // hide element 
    banner.style.display = "none";

    // show element by resetting its display
    banner.style.display = ""; //or "initial"

    Note that initial is a CSS value that works on most CSS properties and means that the browser should use the initial value the element had. Examples:
    A <div> has an initial display of block.
    A <strong> has an initial display of inline.
    An <img> has an initial display of inline-block.




Removing element from the DOM
-----------------------------
If you'd like to remove an element from the DOM, you can use the .remove() method. 

element.remove()
    const headline = document.querySelector("#headline");
    headline.remove();

    The h1#headline will be removed from the DOM. Note that this is different than emptying the contents of an element.


document.body
  If you need to access the <body> element of the page, instead of finding it with querySelector, you can access it with document.body directly:


document.documentElement
Similarly for the <html> tag, you can access it directly with document.documentElement
    document.documentElement.classList.add("dark-mode");


Dataset
--------
 the HTML spec recommends that developers prefix their own custom attributes with data- This avoids potential conflicts with the browser and shows that this is a custom attribute. We call this a data attribute. element.dataset returns an object containing all the data- attributes on that element.

    <-- This is recommended -->
      <form id="payment-form" data-currency="EUR">
        ...
      </form>


  To read this data attribute, you can access the dataset object on the element:
  Notice that the kebab-case (user-id) was automatically converted to camelCase (userId). Also, notice that the value of data attributes is always a string.This may become challenging when reading boolean values. The "false" string is true (because it's a string that contains text).
  const rememberMe = navbar.dataset.rememberMe === "true"; // false

    const form = document.querySelector("#payment-form");
    console.log(form.dataset); // {currency: "EUR"}
    const currency = form.dataset.currency; // "EUR"

    <form id="payment-form" data-currency="EUR" data-user-id="2">
      ...
    </form>

    console.log(form.dataset), you will get:
    {
      userId: "2",
      currency: "EUR"
    }


  write dataset
  You can also update/set a value for a data attribute by assigning it to a new value.

  Assuming the following HTML:
  <div id="navbar" data-user-id="42"></div>

  const navbar = document.querySelector("#navbar");
  navbar.dataset.userId = 43;
  navbar.dataset.rememberMe = false;

  The updated DOM element will look like this:
  <div id="navbar" data-user-id="43" data-remember-me="false"></div>


Traversing The DOM
-------------------
Avoid if possible
You should not rely a lot on these methods as changing the HTML would then break your JavaScript code. It's recommended that you add ids and classes whenever possible.

element.parentElement 
  returns the parent element of the current element

  <div class="article">
    <h1>Hello World</h1>
    <p>Lorem ipsum</p>
  </div>

  const h1 = document.querySelector("h1");
  console.log(h1.parentElement); // <div class="article">...</div>

element.closest("CSS-selector")
  returns the closest parent that matches the CSS-selector you specified.

  <div class="main">
    <div class="banner">
        <h1>Hello World</h1>
    </div>
  </div>

  const h1 = document.querySelector("h1");
  console.log(h1.closest(".main")); // <div class="main">...</div>
  This will look for the closest parent that matches the selector .main that will be the first div with class="main".


Insert adjacent HTML
--------------------
Using innerHTML += ... to add HTML inside an element is inefficient because it recreates the entire HTML. This could also remove existing event listeners.
Instead, when you want to add a piece of HTML, you should use the insertAdjacentHTML method. Always use backticks `` for the second argumet.This is because template strings support multiline strings whereas double quotes and single quotes don't.Another benefit of using template strings is interpolation.
The insertAdjacentHTML method presents the same security risk as innerHTML.
So, you should not use it if the variables you're interpolating might be coming from the user.Similarly, we've got the insertAdjacentText method that will insert text without interpreting HTML.

element.insertAdjacentHTML(position, htmlString)
  will place the htmlString without having to reconstruct the remaining HTML inside the element

  Append
    const positions = document.querySelector("#job-positions");
    positions.insertAdjacentHTML("beforeend", `<div class="position">2015-2020</div>`);
  This will add the html string at the end of the #job-positions element

  Prepend
    const positions = document.querySelector("#job-positions");
    positions.insertAdjacentHTML("afterbegin", `<div class="position">2007-2009</div>`);
  This will add the html string at the begining of the #job-positions element

Array to DOM
  const apps = ["Calculator", "Phone", "Messages"];
  const list = document.querySelector("#apps-list");

  apps.forEach(app => {
    list.insertAdjacentHTML("beforeend", `<li>${app}</li>`);
  });

  The resulting DOM will be:
  <ul id="apps-list">
    <li>Calculator</li>
    <li>Phone</li>
    <li>Messages</li>
  </ul>


innerHTML vs insertAdjacentHTML
  - Do I want to write HTML and overwrite all the previous values? If yes, then  
    use innerHTML.
  - Do I want to keep the previous HTML and add some HTML at the beginning or at 
    the end? If yes, then use insertAdjacentHTML.


















                        _________________________________ 
=====================  |               LINUX             |   ==================
=====================  |_________________________________|   ==================

 ____________________________________
Linux command Line
_____________________________________
$ echo hello world (print to console)
$ echo "Hello Command Line" >> hello_cli.txt (create a new file named hello_cli.txt and add Hello Command Line to that file)
$ date (date)
$ whoami (username)
$ pwd (Print Working Directory)
$ cd (change directory) / is root
    cd .  (current directory). This is the directory you are currently in
    cd .. (parent directory). Takes you to the directory above your current
    cd ~  (home directory). This directory defaults to your “home directory” 
            Such as /home/amurfie2003
    cd -  (previous directory). This will take you to the previous directory you 
            were just at
$ ls (list directories) -a (all) -l(long) combine -la
$ touch index.html (create new empty file/update timestamp)
        touch home/user/index.html (create empty file at path)
$ cat hello-cli.txt (to print the contents of the hello-cli.txt file to the terminal)
$ mkdir new-folder (make directory in current directory)
        mkdir home/user/new-folder (make directory atspecific path)
$ rmdir (remove directory)

TAB-KEY gives auto completion 
UP/DOWN-KEY cycle previous comands











                        __________________________________  
=====================  |           GIT/GITHUB             |   ==================
=====================  |__________________________________|   ==================

https://education.github.com/git-cheat-sheet-education.pdf //cheatsheet

- git init //set up the project to be tracked by git. Should be done in thhe root of the project.

git add <filename>//adds the named file(s) in the working directory to staging area so changes will be tracked by git.
  git add <filename> <filename> //adds both files at the sametime
  git add . //adds all files in current directory to staging area. Be sure to have your 
    .gitignore file set up to avoid commiting sensitive files to repo. 


git commit //Permanently stores all files in the staging area to your local repository
  git commit -m "commit message" //gives the commit a identifying message
    Standard Conventions for Commit Messages:
    -----------------------------------------
    Written in the present tense.
    Should be brief (50 characters or less).

  git commit -a -m "message" //stages and commits files in one command.

  git commit --amend // update your previous commit.It’s important to note that although it seems like --amend is simply updating the commit, what Git actually does is replace the whole previous commit so will need a new commit message.

  git commit --amend --no-edit //keeps the commit message


git status //gives the current state of the files example untracked files 
  this means that git sees the files but they are not being tracked must add them to staging area.

git diff <filename> //this will show the difference between working directory and the staging area. 

git log //This will list all the commits in chronloical order
  In the output:
    A 40-character code, called a SHA, that uniquely identifies the commit
    The commit author
    The date and time of the commit
    The commit message
  git log -s "keyword" //displays a list of commits that contain the keyword in the message.

  git log --oneline --graph //show a graphical representation of commits


git rm --cached <fileName> //deletes file from staging area

git show HEAD //shows everything in git log for HEAD commit  plus all the file changes that were committed. The HEAD is the commit you are currently on in most cases it will be last commit.

git checkout HEAD <filename> //will restore the file in your working directory to look exactly as it did when you last made a commit. Use to undo mistakes.Must close and reopen file.
  shortcut: git checkout -- <filename> 
  does the exact same thing

git reset HEAD <filename> //Removes the file from the staging area.
This command resets the file in the staging area to be the same as the HEAD commit. It does not discard file changes from the working directory.
  output:
    Unstaged changes after reset:              
    M       file.txt

git reset <commit_SHA> //This command works by using the first 7 characters of the SHA of a previous commit. The HEAD is now set to that previous commit which will erase all commits ahead of the current HEAD position. The files are moved back to the staging area.

git stash //Running the command will store your work temporarily for later use in a hidden directory. Often used when you need to switch branches but do not want to 
commit the current code into the repo
  git stach pop //retrieve the stashed code

SETTING UP REPO FOR PUSHING TO GITHUB
======================================
when creating your repo on github's website for a local repository that already exist do not create any files such as readme etc. as this will cause merging issues later, just create them locally.

git config --global user.name "Murphy" //sets your username for commits
git config --global user.email "example@gmail.com" //sets yor email 
git remote -v //this will show the current path for remote repository

Push an existing repository from the command line
--------------------------------------------------
1.  git remote add origin https://github.com/amurfie2003/web-dev-essentials.git
2.  git branch -M main
3.  git push -u origin main

Git Branching & Merging
========================
git branch //shows all branches in the project and indicates with * which branch  you are currently on

git branch new_branch //creates a new branch called new_branch. no white space
  git checkout -b new_branch //creates new_branch and switches to it   

git checkout new_branch //switches to the new_branch

git merge new_branch //merges the changes made on the new_branch into the current branch that you are on.(example main/mater) 

Merge Conflicts
----------------
Note that there can be merge conflicts when merging branches. This will need to be manually resolved. Git will use special markings to indicate the conflicting code
example 
  <<<<<<< HEAD
  -Engage in swordfights with professional pirates
  =======
  -Engage in swordfights with professional pirates such as Smee. 
  >>>>>>> fencing
  -------------------
  to fix delete the version you don't want to keep including all the markings and leave the version you wish to keep.

git branch -d branch_name //delete branch
git branch -D branch_name //delete branch which has not been fully merged

Cloning repo
==============
git clone remote_location clone_name //copies a remote repo to local machine 
  remote_location tells Git where to go to find the remote. This could be a web address, or a filepath
  clone_name is the name you give to the directory in which Git will clone the repository.

Git will give the remote address the name origin when you clone a repo
git remote -v //list git projects remotes example output:
  origin    /home/ccuser/workspace/curriculum/science-quizzes (fetch)
  origin    /home/ccuser/workspace/curriculum/science-quizzes (push)

git fetch //brings changes onto a remote branch. The changes are not merged into your local master branch 
  git merge origin/master //updates your local master branch to the lates version from the remote.

git push origin your_branch_name //will push your branch up to the remote where it will be reviewed and eventually merged into the master branch

Git Workflow
-------------
After cloning a remote
1 Fetch and merge changes from the remote
2 Create a branch to work on a new project feature
3 Develop the feature on your branch and commit your work
4 Fetch and merge from the remote again (in case new commits were made while you were working)
5 Push your branch up to the remote for review

Deploying to GitHub Pages
-------------------------
https://pages.github.com/

Pull Requests
--------------
Pull requests allow for collaborator review and feedback on proposed code changes before they are merged on the main branch.

Rebase
------
Git rebase <branch name> //Reapplies commits on top of another base branch.

Git merge: joins two or more development histories together (creating a new merge commit).
In other words, Git merge preserves history as it happened, whereas rebase rewrites it.
it’s imperative to understand that rebase is a destructive operation and creates new commits, which can make it complicated to track the context of any changes made.One common rule when using rebase is to only use it locally.it’s important to only use rebase on a local branch that we’re working on individually.

.Git Ignore
------------
A .gitignore file lets Git know which files, folders, and patterns to ignore, and not track them.
.gitignore is usually placed in the root directory of the repository
node_modules/   ignoring an entire directory

patterns
*.html 
ignore all files ending in .html

example* 
ignore all files starting with example
index*

!public/index.css 
will ignore all files starting with index except for src/index.css. But, we cannot negate a file inside an ignored directory.

index.[a-i]* 
with both the square bracket and wildcard to .gitignore, we would ignore index.css and index.html but not index.js, since “j” is outside of the [a-i] range.

Forking a repo
------------------
On gitHub click the fork button and select where in your personal gitHub repo you want to copy the project to.

You can then clone the repo to your local machine as usual 

Set the upstream to the original repo so it stays updated with original repo.
  git remote add upstream https://........
To update the forked repo use:
  git fetch upstream

GitHub Tools
-------------
Issues //You can list tasks and organize them into which are open and in progress

GitHub CLI //llows you to directly access and. modify issues and pull requests right from your terminal!

GitHub Actions // add automated tests after a pull request, trigger something after a branch is merged into main among other actions.

GitHub project management









                        __________________________________  
=====================  |               NODE.JS            |   ==================
=====================  |__________________________________|   ==================
For the URL https://www.codecademy.com, “https” is the scheme, “www” is the subdomain, “codecademy” is the domain name, and “com” is the top-level domain.

node //opens the REPL
  .editor //enter editor mode for entering multiple lines
  require('module').builtinModules // will list the builtin modules
  node does not contain the 'window' object
node <myProgram.js> // node will run the program and output the result

console.table(array); //prints array in table format to the console
console.assert(array.length > 5) //method writes an error message to the console
  if the assertion is false. If the assertion is true, nothing happens.












================= RESOURCEES ==================


____________________________________
Books 
_____________________________________

Data structures & algorithms
-----------------------------
computer science distilled
grokking data structures and algorithms
Introduction to Algorithms

Software Engineering & Architecture
-----------------------------
clean code
Refactoring: Improving the Design of Existing Code
The Productive Programmer
Pragmatic Thinking and Learning
clean architecture
The devOps handbook
software engineering at google
understaing distributed systems


Online videos in order
__________________________
Intro to Computer Science (by Ana Bell @ MIT) - https://bit.ly/3oHCWpq
Programming Abstractions (by Julie Zelenski @ Stanford) - https://bit.ly/3n7WfIg
Introduction to Algorithms (by Erik Demaine @ MIT) - https://bit.ly/2JWzd8J
 